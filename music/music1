const { createAudioPlayer, createAudioResource, AudioPlayerStatus, getVoiceConnection, NoSubscriberBehavior } = require('@discordjs/voice');
const fs = require('fs');
const path = require('path');
const fetch = require('node-fetch');

// Store active audio players per guild
const audioPlayers = new Map();
const MUSIC_FOLDER = path.join(__dirname, '..', 'music');

// Helper function to get or create audio player for a guild
function getAudioPlayer(guildId) {
    if (!audioPlayers.has(guildId)) {
        const player = createAudioPlayer({
            behaviors: {
                noSubscriber: NoSubscriberBehavior.Play
            }
        });
        audioPlayers.set(guildId, player);
        
        // Handle when track ends
        player.on(AudioPlayerStatus.Idle, () => {
            if (player.queue && player.queue.length > 0) {
                const nextSong = player.queue.shift();
                playSong(nextSong.guildId, nextSong.filePath, nextSong.client);
            } else {
                // Reset status when no more songs in queue
                const client = player.client;
                if (client) {
                    setCustomStatus(client, 'üí≠ chatting with friends');
                }
            }
        });

        // Handle errors
        player.on('error', error => {
            console.error('Error:', error.message);
        });
    }
    return audioPlayers.get(guildId);
}

// Helper function to get clean filename (without extension)
function getCleanFilename(filePath) {
    return path.basename(filePath).replace(/\.[^/.]+$/, '');
}

// Helper function to set status
function setCustomStatus(client, text) {
    if (client) {
        client.user.setActivity(text, {
            type: "CUSTOM",
            state: text
        });
    }
}

// Helper function to play a song
function playSong(guildId, filePath, client) {
    try {
        const player = getAudioPlayer(guildId);
        const resource = createAudioResource(filePath, {
            inlineVolume: true
        });
        resource.volume.setVolume(1); // Set volume to 200%
        player.play(resource);

        // Store client reference for status updates
        player.client = client;

        // Update status with current song
        if (client) {
            const songName = getCleanFilename(filePath);
            setCustomStatus(client, `üéµ playing ${songName}`);
        }

        // Add error handling for the resource
        resource.playStream.on('error', error => {
            console.error('Error playing file:', error);
        });

        return true;
    } catch (error) {
        console.error('Error playing song:', error);
        return false;
    }
}

// Helper function to get random items from array
function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}

module.exports = [
    {
        name: 'play',
        description: 'Play a music file from the music folder',
        category: 'Music',
        execute(message, args, commandManager) {
            if (!commandManager.isAllowedUser(message.author.id)) return;
            
            // Check if a filename was provided
            if (args.length < 2) {
                return message.reply('Please provide a filename to play. Use `!music list` to see available files.');
            }

            // Get the voice connection
            const connection = getVoiceConnection(message.guild.id);
            if (!connection) {
                return message.reply('I\'m not connected to a voice channel. Use `!vc join <channel_id>` first.');
            }

            // Get the filename and check if it exists
            const searchName = args.slice(1).join(' ').toLowerCase();
            
            try {
                const files = fs.readdirSync(MUSIC_FOLDER);
                const matchingFile = files.find(file => 
                    getCleanFilename(file).toLowerCase() === searchName
                );

                if (!matchingFile) {
                    return message.reply('That file doesn\'t exist in the music folder. Use `!music list` to see available files.');
                }

                const filePath = path.join(MUSIC_FOLDER, matchingFile);

                // Get the player and subscribe the connection
                const player = getAudioPlayer(message.guild.id);
                connection.subscribe(player);

                // Play the song
                if (playSong(message.guild.id, filePath, message.client)) {
                    message.reply(`üéµ Now playing: ${getCleanFilename(matchingFile)}`);
                } else {
                    message.reply('Failed to play the file. Please try again.');
                }
            } catch (error) {
                console.error('Error accessing music folder:', error);
                message.reply('Failed to access the music folder.');
            }
        }
    },
    {
        name: 'mstop',
        description: 'Stop the current music playback',
        category: 'Music',
        execute(message, args, commandManager) {
            if (!commandManager.isAllowedUser(message.author.id)) return;

            const player = audioPlayers.get(message.guild.id);
            if (!player) {
                return message.reply('No music is currently playing.');
            }

            player.stop();
            player.queue = []; // Clear queue if exists
            
            // Reset status
            setCustomStatus(message.client, 'üí≠ chatting with friends');
            
            message.reply('‚èπÔ∏è Stopped music playback.');
        }
    },
    {
        name: 'skip',
        description: 'Skip the current song',
        category: 'Music',
        execute(message, args, commandManager) {
            if (!commandManager.isAllowedUser(message.author.id)) return;

            const player = audioPlayers.get(message.guild.id);
            if (!player) {
                return message.reply('No music is currently playing.');
            }

            if (!player.queue || player.queue.length === 0) {
                player.stop();
                setCustomStatus(message.client, 'üí≠ chatting with friends');
                return message.reply('‚è≠Ô∏è Skipped the last song in queue.');
            }

            const nextSong = player.queue.shift();
            if (playSong(message.guild.id, nextSong.filePath, message.client)) {
                message.reply(`‚è≠Ô∏è Skipped to: ${getCleanFilename(nextSong.filePath)}`);
            } else {
                message.reply('Failed to play next song. Please try again.');
            }
        }
    },
    {
        name: 'music',
        description: 'Music commands',
        category: 'Music',
        async execute(message, args, commandManager) {
            if (!commandManager.isAllowedUser(message.author.id)) return;

            if (args.length < 2) {
                return message.reply(`Available music commands:
‚Ä¢ \`!play <name>\` - Play a music file
‚Ä¢ \`!mstop\` - Stop current playback
‚Ä¢ \`!skip\` - Skip to next song
‚Ä¢ \`!all play\` - Play all music files (random)
‚Ä¢ \`!music list\` - Show available music files`);
            }

            const subCommand = args[1].toLowerCase();

            if (subCommand === 'list') {
                // List all music files
                try {
                    const files = fs.readdirSync(MUSIC_FOLDER);
                    if (files.length === 0) {
                        return message.reply('No music files found in the music folder.');
                    }

                    // Sort files alphabetically
                    const sortedFiles = files.sort((a, b) => 
                        getCleanFilename(a).localeCompare(getCleanFilename(b))
                    );

                    // Calculate total pages
                    const itemsPerPage = 5;
                    const totalPages = Math.ceil(sortedFiles.length / itemsPerPage);
                    let currentPage = 1;

                    // Function to generate page content
                    const getPageContent = (page) => {
                        const start = (page - 1) * itemsPerPage;
                        const end = start + itemsPerPage;
                        const pageFiles = sortedFiles.slice(start, end);
                        
                        return `üìã **Music Files (Page ${page}/${totalPages})**\n\n${
                            pageFiles.map((file, i) => `${start + i + 1}. ${getCleanFilename(file)}`).join('\n')
                        }\n\n‚¨ÖÔ∏è Previous | Next ‚û°Ô∏è`;
                    };

                    // Send initial message
                    const listMsg = await message.reply(getPageContent(currentPage));

                    // Add navigation reactions
                    await listMsg.react('‚¨ÖÔ∏è');
                    await listMsg.react('‚û°Ô∏è');

                    // Create reaction collector
                    const filter = (reaction, user) => 
                        ['‚¨ÖÔ∏è', '‚û°Ô∏è'].includes(reaction.emoji.name) && 
                        user.id === message.author.id;

                    const collector = listMsg.createReactionCollector({ 
                        filter, 
                        time: 60000 // 1 minute timeout
                    });

                    collector.on('collect', async (reaction, user) => {
                        // Remove user's reaction
                        await reaction.users.remove(user.id).catch(console.error);

                        if (reaction.emoji.name === '‚û°Ô∏è' && currentPage < totalPages) {
                            currentPage++;
                            await listMsg.edit(getPageContent(currentPage));
                        }
                        else if (reaction.emoji.name === '‚¨ÖÔ∏è' && currentPage > 1) {
                            currentPage--;
                            await listMsg.edit(getPageContent(currentPage));
                        }
                    });

                    collector.on('end', () => {
                        // Remove reactions when collector ends
                        listMsg.reactions.removeAll().catch(console.error);
                    });

                } catch (error) {
                    console.error('Error reading music folder:', error);
                    message.reply('Failed to read the music folder.');
                }
            }
        }
    },
    {
        name: 'all',
        description: 'Play all music from the music folder',
        category: 'Music',
        execute(message, args, commandManager) {
            if (!commandManager.isAllowedUser(message.author.id)) return;

            if (args.length < 2 || args[1].toLowerCase() !== 'play') {
                return;
            }

            // Get the voice connection
            const connection = getVoiceConnection(message.guild.id);
            if (!connection) {
                return message.reply('I\'m not connected to a voice channel. Use `!vc join <channel_id>` first.');
            }

            // Read all files from the music folder
            try {
                const files = fs.readdirSync(MUSIC_FOLDER);
                if (files.length === 0) {
                    return message.reply('No music files found in the music folder.');
                }

                // Shuffle the files array
                const shuffledFiles = shuffleArray([...files]);

                // Get the player and subscribe the connection
                const player = getAudioPlayer(message.guild.id);
                connection.subscribe(player);

                // Create queue of songs (excluding the first one)
                player.queue = shuffledFiles.slice(1).map(file => ({
                    guildId: message.guild.id,
                    filePath: path.join(MUSIC_FOLDER, file),
                    client: message.client
                }));

                // Play the first song
                if (playSong(message.guild.id, path.join(MUSIC_FOLDER, shuffledFiles[0]), message.client)) {
                    message.reply(`üéµ Playing all music files in random order (${files.length} files)\nStarting with: ${getCleanFilename(shuffledFiles[0])}`);
                } else {
                    message.reply('Failed to start playback. Please try again.');
                }
            } catch (error) {
                console.error('Error reading music folder:', error);
                message.reply('Failed to read the music folder.');
            }
        }
    },
    {
        name: 'supload',
        description: 'Upload a song to the music folder',
        category: 'Music',
        async execute(message, args, commandManager) {
            if (!commandManager.isAllowedUser(message.author.id)) return;

            // Check if a file is attached
            if (!message.attachments.size) {
                return message.reply('Please attach an MP3 file to upload.');
            }

            const attachment = message.attachments.first();
            
            // Check if it's an MP3 file
            if (!attachment.name.toLowerCase().endsWith('.mp3')) {
                return message.reply('Only MP3 files are supported.');
            }

            try {
                // Create music folder if it doesn't exist
                if (!fs.existsSync(MUSIC_FOLDER)) {
                    fs.mkdirSync(MUSIC_FOLDER, { recursive: true });
                }

                // Get the filename (either from args or use the original filename)
                let filename = args.length > 1 ? 
                    args.slice(1).join(' ') + '.mp3' : 
                    attachment.name;

                // Clean the filename (remove special characters)
                filename = filename.replace(/[^a-zA-Z0-9\s\-\_\.]/g, '');

                const filePath = path.join(MUSIC_FOLDER, filename);

                // Download the file
                const response = await fetch(attachment.url);
                const buffer = await response.arrayBuffer();
                
                // Save the file
                fs.writeFileSync(filePath, Buffer.from(buffer));

                message.reply(`‚úÖ Successfully uploaded song: ${getCleanFilename(filename)}`);
            } catch (error) {
                console.error('Error uploading song:', error);
                message.reply('‚ùå Failed to upload the song. Please try again.');
            }
        }
    }
]; 
